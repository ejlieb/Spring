## 비즈니스 요구사항과 설계

- 회원
  - 회원을 가입하고 조회할 수 있다.
  - 회원은 일반과 VIP 두 가지 등급이 있다.
  - 회원 데이터는 자체 DB를 구축할 수 있고 외부 시스템과 연동할 수 있다.(미확정)

- 주문과 할인 정책
  - 회원은 상품을 주문할 수 있다.
  - 회원 등급에 따라 할인 정책을 적용할 수 있다.
  - 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라(나중에 변경될 수 있다.)
  - 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수도 있다.(미확정)

![회원도메인협력관계](README.assets/회원도메인협력관계-16725030223642.PNG)

![회원 클래스 설계](README.assets/회원 클래스 설계-16725030341845.PNG)



---

##### 관심사의 분리

클라이언트인 OrderServiceImpl에서 discount Rate를 실제 구현체를 함께 의존하기 때문에 OCP, DIP 원칙 위배하게 된다.(할인 정책을 바꾸려면 오더서비스 임플의 코드가 변경된다.)



이를 해결하기 위해 클라이언트에서는 인터페이스(discountPolicy)만 의존하고 자동으로 구현객체를 생성하고 연결하는 별도의 설정 클래스를 만든다.



이것이 바로 AppConfig!

- AppConfig는 애플리케이션의 실제 동작에 필요한 구현객체를 생성한다.

- AppConfig는 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입(연결)해준다.



AppConfig(구성영역)을 사용하게 됨으로써 앞으로 변경이 있을 때 사용영역(클라이언트)을 변경할 필요 없이 구성영역만 변경하면 된다!!

---

##### 좋은 객체지향 설계의 5 원칙 적용

1. SRP

한 클래스는 하나의 책임만 가져야 한다!

- 클라이언트 객체가 직접 구현객체를 생성하고, 연결하고 실행하는 다양한 책임을 갖고 있던 구조에서
- 관심사를 분리하고
- 구현 객체 생성 및 연결은 AppConfig가 담당함으로써
- 클라이언트 객체는 실행하는 책임만 담당하게 한다

2. DIP

프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나다.

- 새로운 할인 정책을 개발하고, 적용하려고 하니 클라이언트 코드가 함께 변경되는 기존 코드
- 왜냐하면  클라잉너트 코드가 추상화 인터페이스 뿐만 아니라 구현 클래스에도 함께 의존했기 때문
- 클라잉너트 코드가 추상화 인터페이스에만 의존하도록 하고
- AppConfig가 객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트 코드에 주입하게 함으로 DIP 원칙 준수

3. OCP

소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.

- 다형성 사용하고 클라이언트가 DIP를 지킴
- 애플리케이션을 사용 영역과 구성영역으로 나눔
- AppConfig가 의존관계를 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 됨
- 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다!



---

##### IOC, DI, 그리고 컨테이너

###### 제어의 역전  IOC

- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고 연결하고 실행했다. 한마디로 구녛 객체가 프로그램의 제어 흐름을 스스로 조종
- AppConfig 이후에 구현객제츤 자신의 로직을 실행하는 역할만 수행
- 프로그램의 제어 흐름은 AppConfig에서 담당
- 이처럼 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 IOC라 한다.



###### 프레임워크 vs 라이브러리

- 프레임 워크: 프레임워크가 내가 작성한 코드를 제어하고 대신 실행
- 라이브러리: 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 라이브러리



###### 의존관계 주입 DI

의존 관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계를 구분해서 생각해야 한다.



정적인 클래스 의존관계는 import 코드를 보고 판단 가능. 애플리케이션을 실행하지 않아도 분석할 수 있다.

- ex) OrderServiceImpl에서 DiscountPolicy 인터페이스를 의존한다. 하지만 어떤 구현 객체를가 실제로 주입되게 될지는 모른다.



동적인 객체 인스턴스 의존관계는 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계이다.

- ex) OrderServiceImpl에서 실제 실행 시 FixedDiscountPolicy 객체 인스턴스를 의존한다.



- 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라고 한다.
- 객체 인스턴스를 생성하고 그 참조값을 전달해서 연결된다.
- 의존 관계 주입을 사용하면 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경 가능하다.
- 의존 관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.



###### IoC 컨테이너, DI 컨테이너

- AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을
- IoC컨테이너 혹은 DI 컨테이너라 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
- 어셈블러, 오브젝트 팩토리 등으로 부르기도 한다.





